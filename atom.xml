<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ming&#39;s Blog</title>
  
  <subtitle>Stay hungry Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://traveler-wm.github.io/"/>
  <updated>2019-03-25T11:40:31.642Z</updated>
  <id>https://traveler-wm.github.io/</id>
  
  <author>
    <name>Ming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker学习(四)之springmvc项目部署</title>
    <link href="https://traveler-wm.github.io/2019/03/25/Docker%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E4%B9%8Bspringmvc%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <id>https://traveler-wm.github.io/2019/03/25/Docker学习-四-之springmvc项目部署/</id>
    <published>2019-03-25T11:40:31.000Z</published>
    <updated>2019-03-25T11:40:31.642Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker学习(四)—-SpringMVC项目部署</title>
    <link href="https://traveler-wm.github.io/2019/03/25/Docker%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E2%80%94-SpringMVC%E9%83%A8%E7%BD%B2/"/>
    <id>https://traveler-wm.github.io/2019/03/25/Docker学习-四-—-SpringMVC部署/</id>
    <published>2019-03-25T08:24:08.000Z</published>
    <updated>2019-03-25T11:31:52.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在学习了之前的docker基础后，这次我们便通过部署一个springmvc应用来练练手。默认你已经购买了一台云服务器<br>或者也可以在虚拟机上进行。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/Traveler-WM/BookMS" target="_blank" rel="noopener">https://github.com/Traveler-WM/BookMS</a></p><h2 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h2><ul><li>一个springmvc应用，可以<code>git clone</code>上面的项目</li><li>在云服务器中安装docker并拉取所需的tomcat和mysql镜像</li></ul><p>作为docker实战，我们第一步便检查docker是否安装并正常运行，docker的安装可以参考我之前的博文<br>这里我用的是CentOS 7的Linux系统<br>拉取最新版的tomcat镜像<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p>拉去好后创建mysql容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br></pre></td></tr></table></figure><p>命令解释:</p><ul><li>run -itd：在docker中运行一个带交互式的且能后台运行的容器。</li><li>–name mysql:给容器命名为mysql，注意name前面有两个小横杠，你也可以自己随意命名。</li><li>-p 3306:3306：这里是指将容器的3306端口映射到主机的3306端口，冒号前面指的是主机，后面指的是容器。</li><li>-e MY_ROOT_PASSWORD=123456:这行命令的意思是在创建mysql容器的时候在容器中创建一个root用户，密码为<br>123456，也可以自行设置。</li></ul><p>接下来我们尝试用数据库连接工具navicat连接远程数据库mysql</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1.设置权限（为root分配权限，以便可以远程连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all PRIVILEGES on *.* to root@&apos;%&apos; WITH GRANT OPTION</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>2.由于Mysql5.6以上的版本修改了Password算法，这里需要更新密码算法</p><p>当我们尝试连接时，可能会出现如下的错误</p><p> <img src="https://github.com/Traveler-WM/Traveler-WM.github.io/blob/master/img/error.jpg" alt="error"></p><p>解决途径:</p><p> <img src="https://github.com/Traveler-WM/Traveler-WM.github.io/blob/master/img/mysql.jpg" alt="mysql"></p><p>数据库连接成功后，我们通过命令拉去tomcat镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure><p>接下来部署提供web服务的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 80:8080 --name myweb tomcat</span><br></pre></td></tr></table></figure><p>创建好了tomcat容器后，我们可以在浏览器输入<strong>&lt;你的ip&gt;</strong>检查一下tomcat是否部署成功。</p><p>接下来我们通过命令<code>docker exec -it myweb bash</code>进入myweb容器</p><p>之后看到有一个tomcat目录下有一个webapps的目录，我们需要把之前准备的springmvc应用的工程文件导出为war包，<br>在导入war包之前，我们要查看一下mysql容器的ip，可以通过命令<code>cat /etc/hosts</code>,然后在springmvc工程文件中访问数据库的xml配置文件里修改访问的数据库。</p><p>最后可以通过命令拷贝放到这里的webapps目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mnt/MPS_system.war fa0be9ddda5c1d667be886ad28e9895e37d17b839677e215a0dfb7e961b6c974:/usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><p>这个命令是把在/mnt下的MPS_system.war文件拷贝到myweb容器下的webapps目录下。里面很长的那个字符串是容器的id，这里用myweb应该也可以（myweb是我tomcat容器的容器名字），后面是webapps在容器中的路径，是固定的，直接复制即可。 </p><p>这样tomcat会帮我们解压部署，部署完成之后我们在浏览器中输入服务器ip+war包文件名便可以看到项目成功地运行了起来！！（我们也可以把解压好的目录下的所有文件放到ROOT目录下，该目录是tomcat的默认运行目录，这样我们可以直接通过地址栏中输入ip运行项目）</p><p>ps:可以用通过目录挂载的方式保存项目数据。</p><p>原因:<br>只要是容器内的数据，当容器删除或者重启时，以前的数据就会消失，于是搜索问题发现的解决的方法是Docker目录挂载从镜像启动容器的时候，用-v的命令，将容器里的目录和宿主机的一个目录关联起来，容器里面目录里面的内容如果修改了，宿主机挂载的目录里面的内容也会跟着修改，而且当容器被删除时，宿主机里面的数据不会消失。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/bad_yu/article/details/81098032" target="_blank" rel="noopener">https://blog.csdn.net/bad_yu/article/details/81098032</a></li><li><a href="https://blog.csdn.net/xsj34567/article/details/80940238" target="_blank" rel="noopener">https://blog.csdn.net/xsj34567/article/details/80940238</a></li><li><a href="https://blog.csdn.net/wchenjt/article/details/79118798" target="_blank" rel="noopener">https://blog.csdn.net/wchenjt/article/details/79118798</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;在学习了之前的docker基础后，这次我们便通过部署一个springmvc应用来练练手。默认你已经购买了一台云服务器&lt;br&gt;或者也可以在虚拟机上进行。&lt;/p&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;#项目地址&quot; class=&quot;headerlink&quot; title=&quot;项目地址&quot;&gt;&lt;/a&gt;项目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Traveler-WM/BookMS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Traveler-WM/BookMS&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;部署准备&quot;&gt;&lt;a href=&quot;#部署准备&quot; class=&quot;headerlink&quot; title=&quot;部署准备&quot;&gt;&lt;/a&gt;部署准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个springmvc应用，可以&lt;code&gt;git clone&lt;/code&gt;上面的项目&lt;/li&gt;
&lt;li&gt;在云服务器中安装docker并拉取所需的tomcat和mysql镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为docker实战，我们第一步便检查docker是否安装并正常运行，docker的安装可以参考我之前的博文&lt;br&gt;这里我用的是CentOS 7的Linux系统&lt;br&gt;拉取最新版的tomcat镜像&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker springmvc" scheme="https://traveler-wm.github.io/tags/docker-springmvc/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习(四)之SpringMVC项目部署</title>
    <link href="https://traveler-wm.github.io/2019/03/25/Docker%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E2%80%94-SpringMVC%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <id>https://traveler-wm.github.io/2019/03/25/Docker学习-四-—-SpringMVC项目部署/</id>
    <published>2019-03-25T08:24:08.000Z</published>
    <updated>2019-03-25T11:43:15.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在学习了之前的docker基础后，这次我们便通过部署一个springmvc应用来练练手。默认你已经购买了一台云服务器<br>或者也可以在虚拟机上进行。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/Traveler-WM/BookMS" target="_blank" rel="noopener">https://github.com/Traveler-WM/BookMS</a></p><h2 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h2><ul><li>一个springmvc应用，可以<code>git clone</code>上面的项目</li><li>在云服务器中安装docker并拉取所需的tomcat和mysql镜像</li></ul><p>作为docker实战，我们第一步便检查docker是否安装并正常运行，docker的安装可以参考我之前的博文<br>这里我用的是CentOS 7的Linux系统<br>拉取最新版的tomcat镜像<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p>拉去好后创建mysql容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br></pre></td></tr></table></figure><p>命令解释:</p><ul><li>run -itd：在docker中运行一个带交互式的且能后台运行的容器。</li><li>–name mysql:给容器命名为mysql，注意name前面有两个小横杠，你也可以自己随意命名。</li><li>-p 3306:3306：这里是指将容器的3306端口映射到主机的3306端口，冒号前面指的是主机，后面指的是容器。</li><li>-e MY_ROOT_PASSWORD=123456:这行命令的意思是在创建mysql容器的时候在容器中创建一个root用户，密码为<br>123456，也可以自行设置。</li></ul><p>接下来我们尝试用数据库连接工具navicat连接远程数据库mysql</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1.设置权限（为root分配权限，以便可以远程连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all PRIVILEGES on *.* to root@&apos;%&apos; WITH GRANT OPTION</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>2.由于Mysql5.6以上的版本修改了Password算法，这里需要更新密码算法</p><p>当我们尝试连接时，可能会出现如下的错误</p><p> <img src="/2019/03/25/Docker学习-四-—-SpringMVC项目部署/Docker学习-四-之springmvc项目部署/error.jpg" alt="error"></p><p>解决途径:</p><p> <img src="/2019/03/25/Docker学习-四-—-SpringMVC项目部署/Docker学习-四-之springmvc项目部署/mysql.jpg" alt="mysql"></p><p>数据库连接成功后，我们通过命令拉去tomcat镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure><p>接下来部署提供web服务的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 80:8080 --name myweb tomcat</span><br></pre></td></tr></table></figure><p>创建好了tomcat容器后，我们可以在浏览器输入<strong>&lt;你的ip&gt;</strong>检查一下tomcat是否部署成功。</p><p>接下来我们通过命令<code>docker exec -it myweb bash</code>进入myweb容器</p><p>之后看到有一个tomcat目录下有一个webapps的目录，我们需要把之前准备的springmvc应用的工程文件导出为war包，<br>在导入war包之前，我们要查看一下mysql容器的ip，可以通过命令<code>cat /etc/hosts</code>,然后在springmvc工程文件中访问数据库的xml配置文件里修改访问的数据库。</p><p>最后可以通过命令拷贝放到这里的webapps目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mnt/MPS_system.war fa0be9ddda5c1d667be886ad28e9895e37d17b839677e215a0dfb7e961b6c974:/usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><p>这个命令是把在/mnt下的MPS_system.war文件拷贝到myweb容器下的webapps目录下。里面很长的那个字符串是容器的id，这里用myweb应该也可以（myweb是我tomcat容器的容器名字），后面是webapps在容器中的路径，是固定的，直接复制即可。 </p><p>这样tomcat会帮我们解压部署，部署完成之后我们在浏览器中输入服务器ip+war包文件名便可以看到项目成功地运行了起来！！（我们也可以把解压好的目录下的所有文件放到ROOT目录下，该目录是tomcat的默认运行目录，这样我们可以直接通过地址栏中输入ip运行项目）</p><p>ps:可以用通过目录挂载的方式保存项目数据。</p><p>原因:<br>只要是容器内的数据，当容器删除或者重启时，以前的数据就会消失，于是搜索问题发现的解决的方法是Docker目录挂载从镜像启动容器的时候，用-v的命令，将容器里的目录和宿主机的一个目录关联起来，容器里面目录里面的内容如果修改了，宿主机挂载的目录里面的内容也会跟着修改，而且当容器被删除时，宿主机里面的数据不会消失。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/bad_yu/article/details/81098032" target="_blank" rel="noopener">https://blog.csdn.net/bad_yu/article/details/81098032</a></li><li><a href="https://blog.csdn.net/xsj34567/article/details/80940238" target="_blank" rel="noopener">https://blog.csdn.net/xsj34567/article/details/80940238</a></li><li><a href="https://blog.csdn.net/wchenjt/article/details/79118798" target="_blank" rel="noopener">https://blog.csdn.net/wchenjt/article/details/79118798</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;在学习了之前的docker基础后，这次我们便通过部署一个springmvc应用来练练手。默认你已经购买了一台云服务器&lt;br&gt;或者也可以在虚拟机上进行。&lt;/p&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;#项目地址&quot; class=&quot;headerlink&quot; title=&quot;项目地址&quot;&gt;&lt;/a&gt;项目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Traveler-WM/BookMS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Traveler-WM/BookMS&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;部署准备&quot;&gt;&lt;a href=&quot;#部署准备&quot; class=&quot;headerlink&quot; title=&quot;部署准备&quot;&gt;&lt;/a&gt;部署准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个springmvc应用，可以&lt;code&gt;git clone&lt;/code&gt;上面的项目&lt;/li&gt;
&lt;li&gt;在云服务器中安装docker并拉取所需的tomcat和mysql镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为docker实战，我们第一步便检查docker是否安装并正常运行，docker的安装可以参考我之前的博文&lt;br&gt;这里我用的是CentOS 7的Linux系统&lt;br&gt;拉取最新版的tomcat镜像&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker springmvc" scheme="https://traveler-wm.github.io/tags/docker-springmvc/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习(三)之Dockerfile笔记</title>
    <link href="https://traveler-wm.github.io/2019/03/15/Docker%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E4%B9%8BDockerfile%E4%BB%8B%E7%BB%8D/"/>
    <id>https://traveler-wm.github.io/2019/03/15/Docker学习-三-之Dockerfile介绍/</id>
    <published>2019-03-15T02:25:44.000Z</published>
    <updated>2019-03-15T05:16:18.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile构建镜像"><a href="#Dockerfile构建镜像" class="headerlink" title="Dockerfile构建镜像"></a>Dockerfile构建镜像</h1><p>镜像作为Docker的一个重要概念，其实际上就是定制每一层所添加的配置、文件。而Dockerfile就是一个脚本文件，用于把该每一层修改、安装、构建、操作的命令写入其中来构建、定制镜像。</p><p>Dockerfile是一个文本文档，其中包含用户可以在命令行上调用来构建镜像的所有命令。 使用Dockerfile用户可以创建一个连续执行多个命令行指令的镜像。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>以构建nginx镜像为例，在一个空白目录，建立一个文本文件，并命名为 dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mynginx</span><br><span class="line">$ cd mynginx</span><br><span class="line">$ touch dockerfile</span><br></pre></td></tr></table></figure><p>在该dockerfile中写入内容:<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p><p>这个dockerile比较简单，用到了<code>FROM</code>和<code>RUN</code>两条命令，意思是基于nginx镜像,运行echo命令重定向输出<code>&lt;h1&gt;</code>标签内容到index.html文件中</p><h1 id="Dockerfile常用命令"><a href="#Dockerfile常用命令" class="headerlink" title="Dockerfile常用命令"></a>Dockerfile常用命令</h1><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p>格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br><span class="line">或</span><br><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>FROM在Dockerfile中是必须的指令，而且必须是第一条指令。它以一个镜像为基础，在其上进行定制，该基础镜像首选本地是否存在，如果不存在则会从公共仓库下载（当然也可以使用私有仓库的格式）</p><ul><li>通过Docker Hub官方镜像仓库的镜像，比如服务类(nginx/redis)、语言类(node/openjdk/python)、操作系统类(ubuntu/debian/centos)等，我们可以直接pull下来进行基础构建。</li><li>除了选择现有的镜像作为基础镜像外，Docker还存在一个特殊的镜像，名为scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像 </li></ul><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>run指令是用来执行命令行命令的，定制镜像时是最常用的指令之一。其格式有两种:</p><ul><li>shell格式： RUN 命令，就像直接在命令行中输入的命令一样，如RUN echo ‘hello, world!’ &gt; hello.txt</li><li>exec格式：RUN [‘可执行文件’, ‘参数1’, ‘参数2’]，这更像是函数调用中的格式。如RUN /bin/bash -c ‘source $HOME/.bashrc; echo $HOME’</li></ul><p>Dockerfile中每一个指令都会建立一层，RUN也不例外。每一个RUN的行为，就和刚才我们手工建立镜像的过程一样:新建立一层，在其上执行这些命令，执行结束后，commit这一层的修改，构成新的镜像。所以在使用RUN命令时应当尽可能地减少层数，避免构建了多层、臃肿的镜像，既增加了构建部署的时间，也很容易出错（可以使用&amp;&amp;将各个所需命令串联起来）</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD指令的主要功能是在build完成后，为了给docker run启动到容器时提供默认命令或参数，这些默认值可以包含可执行的命令，也可以只是参数（此时可执行命令就必须提前在ENTRYPOINT中指定)。Dockerfile中只能有一条CMD指令。如果列出多个CMD，则只有最后一个CMD才会生效</p><p>CMD命令包含三种结构:</p><ul><li>CMD [“executable”,”param1”,”param2”] (exec格式首选)</li><li>CMD [“param1”,”param2”] (作为ENTRYPOINT的默认变量)</li><li>CMD command param1 param2 (shell格式)</li></ul><p>CMD与RUN的区别在于，RUN是在build成镜像时就运行的，先于CMD和ENTRYPOINT的，CMD会在每次启动容器的时候运行，而RUN只在创建镜像时执行一次，固化在image中。</p><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>将文件<code>&lt;src&gt;</code>拷贝到container的文件系统对应的路径<code>&lt;dest&gt;</code>下。<code>&lt;src&gt;</code>可以是文件、文件夹、URL，对于文件和文件夹<src>必须是在Dockerfile的相对路径下（build context path），即只能是相对路径且不能包含../path/。</src></p><p><code>&lt;dest&gt;</code>只能是容器中的绝对路径。如果路径不存在则会自动级联创建，根据你的需要是<code>&lt;dest&gt;</code>里是否需要反斜杠/，习惯使用/结尾从而避免被当成文件</p><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p>COPY 指令将从构建上下文目录中&lt;源路径&gt;的文件复制到新的一层的镜像内的&lt;目标路径&gt;位置。</p><p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用：</p><p>COPY &lt;源路径&gt;… &lt;目标路径&gt;<br>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</p><p>COPY的语法与功能与ADD相同，只是不支持上面讲到的<src>是远程URL、自动解压这两个特性。推荐使用COPY，虽然COPY只支持本地文件拷贝到container，但它的处理比ADD更加透明，建议只在复制tar文件时使用ADD，如ADD trusty-core-amd64.tar.gz /。</src></p><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>用于设置环境变量<br>格式有两种：</p><ul><li>ENV <code>&lt;key&gt;</code> <code>&lt;value&gt;</code></li><li>ENV <code>&lt;key1&gt;</code>=<code>&lt;value1&gt;</code> <code>&lt;key2&gt;</code>=<code>&lt;value2&gt;</code>…</li></ul><p>设置了后，后续的RUN命令都可以使用，当运行生成的镜像时这些环境变量依然有效，如果需要在运行时更改这些环境变量可以在运行docker run时添加-env <code>&lt;key&gt;</code>=<code>&lt;value&gt;</code>参数来修改。</p><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>EXPOSE指令告诉容器在运行时要监听的端口，但是这个端口是用于多个容器之间通信用的（links），外面的host是访问不到的。要把端口暴露给外面的主机，在启动容器时使用-p选项。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># expose memcached(s) port</span><br><span class="line">EXPOSE 11211 11212</span><br></pre></td></tr></table></figure><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>WORKDIR指令用于设置Dockerfile中的RUN、CMD和ENTRYPOINT指令执行命令的工作目录(默认为/目录)，该指令在Dockerfile文件中可以出现多次，如果使用相对路径则为相对于WORKDIR上一次的值，例如WORKDIR /a，WORKDIR b，RUN pwd最终输出的当前目录是/a/b。（RUN cd /a/b，RUN pwd是得不到/a/b的）</p><h1 id="Dockerfile示例"><a href="#Dockerfile示例" class="headerlink" title="Dockerfile示例"></a>Dockerfile示例</h1><p>下面的Dockerfile是MySQL官方镜像的构建过程。从ubuntu基础镜像开始构建，安装mysql-server、配置权限、映射目录和端口，CMD在从这个镜像运行到容器时启动mysql。其中VOLUME定义的两个可挂载点，用于在host中挂载，因为数据库保存在主机上而非容器中才是比较安全的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># MySQL Dockerfile</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># https://github.com/dockerfile/mysql</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pull base image.</span></span><br><span class="line">FROM dockerfile/ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install MySQL.</span></span><br><span class="line">RUN \</span><br><span class="line">  apt-get update &amp;&amp; \</span><br><span class="line">  DEBIAN_FRONTEND=noninteractive apt-get install -y mysql-server &amp;&amp; \</span><br><span class="line">  rm -rf /var/lib/apt/lists/* &amp;&amp; \</span><br><span class="line">  sed -i <span class="string">'s/^\(bind-address\s.*\)/# \1/'</span> /etc/mysql/my.cnf &amp;&amp; \</span><br><span class="line">  sed -i <span class="string">'s/^\(log_error\s.*\)/# \1/'</span> /etc/mysql/my.cnf &amp;&amp; \</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"mysqld_safe &amp;"</span> &gt; /tmp/config &amp;&amp; \</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"mysqladmin --silent --wait=30 ping || exit 1"</span> &gt;&gt; /tmp/config &amp;&amp; \</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"mysql -e 'GRANT ALL PRIVILEGES ON *.* TO \"root\"@\"%\" WITH GRANT OPTION;'"</span> &gt;&gt; /tmp/config &amp;&amp; \</span><br><span class="line">  bash /tmp/config &amp;&amp; \</span><br><span class="line">  rm -f /tmp/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define mountable directories.</span></span><br><span class="line">VOLUME [<span class="string">"/etc/mysql"</span>, <span class="string">"/var/lib/mysql"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define working directory.</span></span><br><span class="line">WORKDIR /data</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define default command.</span></span><br><span class="line">CMD [<span class="string">"mysqld_safe"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expose ports.</span></span><br><span class="line">EXPOSE 3306</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t=<span class="string">"dockerfile/mysql"</span> github.com/dockerfile/mysql</span><br><span class="line"></span><br><span class="line">或下载Dockerfile内容再当前目录：</span><br><span class="line">$ docker build -t=<span class="string">"dockerfile/mysql"</span> .</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name mysql -p 3306:3306 dockerfile/mysql</span><br><span class="line">或</span><br><span class="line">$ docker run -it --rm --link mysql:mysql dockerfile/mysql bash -c <span class="string">'mysql -h $MYSQL_PORT_3306_TCP_ADDR'</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a></li><li><a href="http://seanlook.com/2014/11/17/dockerfile-introduction/" target="_blank" rel="noopener">Dockerfile指令详解</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/image/build.html" target="_blank" rel="noopener">Docker——从入门到实践</a></li><li><a href="https://blog.devzeng.com/blog/build-docker-image-with-dockerfile.html" target="_blank" rel="noopener">使用Dockerfile构建Docker镜像</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dockerfile构建镜像&quot;&gt;&lt;a href=&quot;#Dockerfile构建镜像&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile构建镜像&quot;&gt;&lt;/a&gt;Dockerfile构建镜像&lt;/h1&gt;&lt;p&gt;镜像作为Docker的一个重要概念，其实际上就是定制每一层所添加的配置、文件。而Dockerfile就是一个脚本文件，用于把该每一层修改、安装、构建、操作的命令写入其中来构建、定制镜像。&lt;/p&gt;
&lt;p&gt;Dockerfile是一个文本文档，其中包含用户可以在命令行上调用来构建镜像的所有命令。 使用Dockerfile用户可以创建一个连续执行多个命令行指令的镜像。&lt;/p&gt;
&lt;h2 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例:&quot;&gt;&lt;/a&gt;实例:&lt;/h2&gt;&lt;p&gt;以构建nginx镜像为例，在一个空白目录，建立一个文本文件，并命名为 dockerfile:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir mynginx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd mynginx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ touch dockerfile&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在该dockerfile中写入内容:&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://traveler-wm.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习(二)之Docker常用命令</title>
    <link href="https://traveler-wm.github.io/2019/03/10/Docker%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%E4%B9%8BDocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://traveler-wm.github.io/2019/03/10/Docker学习(二)之Docker常用命令/</id>
    <published>2019-03-10T02:08:34.000Z</published>
    <updated>2019-03-10T05:41:12.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看Docker信息"><a href="#查看Docker信息" class="headerlink" title="查看Docker信息"></a>查看Docker信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#显示Docker版本信息</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"># 显示Docker系统信息</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h1 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h1><h2 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 从Docker Hub查找镜像</span><br><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><a id="more"></a><p>OPTIONS说明</p><ul><li>automated :只列出 automated build类型的镜像</li><li>–no-trunc :显示完整的镜像描述</li><li>-s :列出收藏数不小于指定值的镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查找收藏数大于30的java镜像</span><br><span class="line">docker search -s 30 java</span><br></pre></td></tr></table></figure><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Docker Hub中拉取镜像</span><br><span class="line">docker pull [OPTIONS] NAME[:Tag|DIGEST]</span><br><span class="line"></span><br><span class="line"># 下载java最新版镜像</span><br><span class="line">docker pull java</span><br><span class="line"></span><br><span class="line"># 下载所有名为java的镜像</span><br><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure><h2 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将本地镜像上传到镜像仓库，先登陆镜像仓库</span><br><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br><span class="line"></span><br><span class="line"># 上传本地镜像mynginx:v1到镜像仓库中</span><br><span class="line">docker push mynginx:v1</span><br></pre></td></tr></table></figure><h2 id="Docker-login-logout"><a href="#Docker-login-logout" class="headerlink" title="Docker login/logout"></a>Docker login/logout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 登录到Docker Hub</span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line"># 登出Docker Hub</span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure><h1 id="本地镜像仓库"><a href="#本地镜像仓库" class="headerlink" title="本地镜像仓库"></a>本地镜像仓库</h1><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地镜像列表</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"># 列出名为java的镜像列表</span><br><span class="line">docker images java</span><br></pre></td></tr></table></figure><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除本地一个或多个镜像</span><br><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]  </span><br><span class="line"></span><br><span class="line"># 强制删除本地镜像my/nginx:v1</span><br><span class="line">docker rmi -f my/nginx:v1</span><br></pre></td></tr></table></figure><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用Dockerfile创建镜像</span><br><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>OPTIONS说明</p><ul><li>-t 指定镜像的名字 </li><li>-f 指定要使用的Dockerfile路径(Dockerfile 可不在当前路径下）</li></ul><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 最后的.代表使用当前目录的Dockerfile创建镜像</span><br><span class="line">docker build -t my/nginx:v1 .</span><br><span class="line"></span><br><span class="line"># 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span><br><span class="line">docker build github.com/creack/docker-firefox</span><br></pre></td></tr></table></figure><h1 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h1><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个新的容器并运行一个命令</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明</p><ul><li>-d: 后台运行容器，并返回容器ID</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用</li><li>–name: 为容器指定一个名称</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致</li><li>-m :设置容器使用内存最大值</li><li>-p: 映射宿主端口到内部容器开放的网络端口，可以多次使用-p来绑定多个端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</span><br><span class="line">docker run --name mynginx -d nginx:latest</span><br><span class="line"></span><br><span class="line"># 使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data。</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line"></span><br><span class="line"># 使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令</span><br><span class="line">docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><h2 id="docker-start-stop-restart"><a href="#docker-start-stop-restart" class="headerlink" title="docker start/stop/restart"></a>docker start/stop/restart</h2><ul><li>docker start :启动一个或多少已经被停止的容器</li><li>docker stop :停止一个运行中的容器</li><li>docker restart :重启容器</li></ul><h2 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 杀掉运行中的容器mynginx</span><br><span class="line">docker kill mynginx</span><br></pre></td></tr></table></figure><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除一个或多个容器</span><br><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明</p><ul><li>-f :通过SIGKILL信号强制删除一个运行中的容器</li><li>-l :移除容器间的网络连接，而非容器本身</li><li>-v :删除与容器关联的卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 强制删除容器db01、db02</span><br><span class="line">docker rm -f db01、db02</span><br><span class="line"></span><br><span class="line"># 移除容器nginx01对容器db01的连接，连接名db</span><br><span class="line">docker rm -l db </span><br><span class="line"></span><br><span class="line"># 删除容器nginx01,并删除容器挂载的数据卷</span><br><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure><h2 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在运行的容器中执行命令</span><br><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明</p><ul><li>-d :分离模式: 在后台运行</li><li>-i :即使没有附加也保持STDIN 打开</li><li>-t :分配一个伪终端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在容器mynginx中开启一个交互模式的终端</span><br><span class="line">docker exec -it  mynginx /bin/bash</span><br><span class="line"></span><br><span class="line"># 在容器mynginx中以交互模式执行容器内/root/youj.sh脚本</span><br><span class="line">docker exec -it mynginx /bin/sh /root/youj.sh</span><br></pre></td></tr></table></figure><h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有在运行的容器信息</span><br><span class="line">   docker ps</span><br><span class="line"></span><br><span class="line"># 列出最近创建的5个容器信息</span><br><span class="line">   docker ps -n 5</span><br><span class="line"></span><br><span class="line"># 列出所有创建的容器ID</span><br><span class="line">   docker ps -a -q</span><br></pre></td></tr></table></figure><h2 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看容器mymysql的进程信息</span><br><span class="line">docker top mymysql</span><br></pre></td></tr></table></figure><h2 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 跟踪查看容器mynginx的日志输出</span><br><span class="line">docker logs -f mynginx</span><br><span class="line"></span><br><span class="line"># 查看容器mynginx从2019年3月1日后的最新10条日志     </span><br><span class="line">docker logs --since=&quot;2019-03-01&quot; --tail=10 mynginx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查看Docker信息&quot;&gt;&lt;a href=&quot;#查看Docker信息&quot; class=&quot;headerlink&quot; title=&quot;查看Docker信息&quot;&gt;&lt;/a&gt;查看Docker信息&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#显示Docker版本信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示Docker系统信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker info&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;镜像仓库&quot;&gt;&lt;a href=&quot;#镜像仓库&quot; class=&quot;headerlink&quot; title=&quot;镜像仓库&quot;&gt;&lt;/a&gt;镜像仓库&lt;/h1&gt;&lt;h2 id=&quot;docker-search&quot;&gt;&lt;a href=&quot;#docker-search&quot; class=&quot;headerlink&quot; title=&quot;docker search&quot;&gt;&lt;/a&gt;docker search&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 从Docker Hub查找镜像&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker search [OPTIONS] TERM&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://traveler-wm.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习(一)之Docker简介和安装</title>
    <link href="https://traveler-wm.github.io/2019/03/08/docker%E5%AD%A6%E4%B9%A0(%E4%B8%80)%E4%B9%8BDocker%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/"/>
    <id>https://traveler-wm.github.io/2019/03/08/docker学习(一)之Docker简介和安装/</id>
    <published>2019-03-08T11:01:45.000Z</published>
    <updated>2019-03-10T04:48:37.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>Docker是开发人员和系统管理员使用容器开发，部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。</code></pre><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>Docker 启动快速属于秒级别。</li><li>Docker 需要的资源更少。Docker 在操作系统级别进行虚拟化，Docker 容器和内核交互，几乎没有性能损耗。</li><li>Docker 更轻量。Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。</li><li>高可用和可恢复性。Docker 对业务的高可用支持是通过快速重新部署实现的。</li><li>虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制。<a id="more"></a></li><li>快速创建、删除。虚拟化创建是分钟级别的，Docker 容器创建是秒级别的，Docker 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间</li></ul><h2 id="容器和镜像"><a href="#容器和镜像" class="headerlink" title="容器和镜像"></a>容器和镜像</h2><pre><code>一个容器通过镜像启动。镜像是一个可执行包，包含运行应用程序所需的所有内容——代码、运行时、库、环境变量和配置文件。容器是镜像运行时的实例  </code></pre><h2 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h2><pre><code>容器在Linux上本机运行，并与其他容器共享主机的内核。它运行一个独立的进程，不占用任何其他可执行文件的内存，使其轻量级。相比之下，虚拟机（VM）运行一个完整的“客户”操作系统，通过虚拟机管理程序对主机资源进行虚拟访问。通常，VM提供的环境比大多数应用程序需要的资源更多。    </code></pre><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><p><strong>卸载掉旧版本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></p><p> <strong>安装依赖包</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">      device-mapper-persistent-data \</span><br><span class="line">      lvm2</span><br></pre></td></tr></table></figure></p><p> <strong>设置稳定版仓库</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></p><p><strong>安装最新版Docker CE</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></p><p><strong>启动Docker</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></p><p><strong>运行hellow-word镜像</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure></p><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p><strong>卸载可能存在的旧版本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure></p><p><strong>更新apt索引包</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p><p><strong>安装包通过https使用repository</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></p><p><strong>添加Docker的官方GPG密钥</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></p><p><strong>更新apt包索引</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></p><p><strong>安装最新版Docker CE</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></p><p><strong>PS:安装特定版本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure><p><strong>运行hello-word镜像</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://dockone.io/article/8350" target="_blank" rel="noopener">http://dockone.io/article/8350</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker简介&quot;&gt;&lt;a href=&quot;#Docker简介&quot; class=&quot;headerlink&quot; title=&quot;Docker简介&quot;&gt;&lt;/a&gt;Docker简介&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Docker是开发人员和系统管理员使用容器开发，部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Docker 启动快速属于秒级别。&lt;/li&gt;
&lt;li&gt;Docker 需要的资源更少。Docker 在操作系统级别进行虚拟化，Docker 容器和内核交互，几乎没有性能损耗。&lt;/li&gt;
&lt;li&gt;Docker 更轻量。Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。&lt;/li&gt;
&lt;li&gt;高可用和可恢复性。Docker 对业务的高可用支持是通过快速重新部署实现的。&lt;/li&gt;
&lt;li&gt;虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://traveler-wm.github.io/tags/docker/"/>
    
  </entry>
  
</feed>
