<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ming&#39;s Blog</title>
  
  <subtitle>Stay hungry Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://traveler-wm.github.io/"/>
  <updated>2019-04-10T16:04:38.661Z</updated>
  <id>https://traveler-wm.github.io/</id>
  
  <author>
    <name>Ming</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring和Spring MVC总结</title>
    <link href="https://traveler-wm.github.io/2019/04/10/Spring%E5%92%8CSpring-MVC%E6%80%BB%E7%BB%93/"/>
    <id>https://traveler-wm.github.io/2019/04/10/Spring和Spring-MVC总结/</id>
    <published>2019-04-10T15:02:15.000Z</published>
    <updated>2019-04-10T16:04:38.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习Spring家族的时候，不免接触到许多底层概念和原理，于是为加深理解和印象，网上找到了一位大神的总结，特意转载学习~</p><p><a href="https://www.cnblogs.com/doudouxiaoye/p/5693399.html" target="_blank" rel="noopener">本文部分转载至这里</a></p><h2 id="为什么使用Spring"><a href="#为什么使用Spring" class="headerlink" title="为什么使用Spring ?"></a>为什么使用Spring ?</h2><ul><li>1). 方便解耦，简化开发<br>通过Spring提供的IoC容器，可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。</li><li>2). AOP编程的支持<br>通过Spring提供的AOP功能，方便进行面向切面的编程，如性能监测、事务管理、日志记录等。</li><li>3). 声明式事务的支持</li><li>4). 方便集成各种优秀框架</li><li>5). 降低Java EE API的使用难度<br>如对JDBC，JavaMail，远程调用等提供了简便封装</li></ul><h2 id="什么是IoC，为什使用IoC"><a href="#什么是IoC，为什使用IoC" class="headerlink" title="什么是IoC，为什使用IoC ?"></a>什么是IoC，为什使用IoC ?</h2><p>IoC全称Iversion of Controller，控制反转。<br>这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。<br>它能指导我们如何设计出松耦合、更优良的程序。<br><a id="more"></a></p><h2 id="什么是AOP，为什么使用AOP"><a href="#什么是AOP，为什么使用AOP" class="headerlink" title="什么是AOP，为什么使用AOP ?"></a>什么是AOP，为什么使用AOP ?</h2><p>AOP全称：Aspect-Oriented Programming，面向切面编程。<br>AOP，面向切面编程，就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中，比如事务管理、权限控制、日志记录、性能统计等。</p><p>AOP并没有帮助我们解决任何新的问题，它只是提供了一种更好的办法，能够用更少的工作量来解决现有的一些问题，使得系统更加健壮，可维护性更好。</p><h2 id="什么是Spring的事务管理？"><a href="#什么是Spring的事务管理？" class="headerlink" title="什么是Spring的事务管理？"></a>什么是Spring的事务管理？</h2><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。<br>开发中为了避免这种情况一般都会进行事务管理。<br>Spring的声明式事务通常是指在配置文件中对事务进行配置声明，其中包括了很多声明属性，它是通过Spring Proxy帮你做代理，自己不用额外的写代码，只要在Spring配置文件中声明即可；通常用在数据库的操作里面；<br>编程式事务就是指通过硬编码的方式做事务处理，这种处理方式需要写代码，事务中的逻辑可以自己定制；可以是数据库的东东，也可以是其他的操作。<br>Spring中也有自己的事务管理机制，一般是使用TransactionMananger进行管理，可以通过Spring的注入来完成此功能。</p><h2 id="Spring框架支持以下五种bean的作用域："><a href="#Spring框架支持以下五种bean的作用域：" class="headerlink" title="Spring框架支持以下五种bean的作用域："></a>Spring框架支持以下五种bean的作用域：</h2><p>singleton : 默认值，bean在每个Spring ioc 容器中只有一个实例。<br>prototype：一个bean的定义可以有多个实例。<br>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p><h2 id="什么是Spring的MVC框架？"><a href="#什么是Spring的MVC框架？" class="headerlink" title="什么是Spring的MVC框架？"></a>什么是Spring的MVC框架？</h2><p>Spring 配备构建Web 应用的全功能MVC框架。Spring可以很便捷地和其他MVC框架集成，如Struts，Spring 的MVC框架用控制反转把业务对象和控制逻辑清晰地隔离。它也允许以声明的方式把请求参数和业务对象绑定。<br>spring mvc是一个基于mvc的web框架。spring mvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。</p><h2 id="Spring-MVC的请求流程："><a href="#Spring-MVC的请求流程：" class="headerlink" title="Spring MVC的请求流程："></a>Spring MVC的请求流程：</h2><p>第一步：发起请求到前端控制器(DispatcherServlet)<br>第二步：前端控制器请求HandlerMapping查找Handler可以根据xml配置、注解进行查找<br>第三步：处理器映射器HandlerMapping向前端控制器返回Handler<br>第四步：前端控制器调用处理器适配器去执行Handler<br>第五步：处理器适配器去执行Handler<br>第六步：Handler执行完成给适配器返回ModelAndView<br>第七步：处理器适配器向前端控制器返回ModelAndView。ModelAndView是springmvc框架的一个底层对象，包括 Model和view<br>第八步：前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(jsp)<br>第九步：视图解析器向前端控制器返回View<br>第十步：前端控制器进行视图渲染。视图渲染将模型数据(在ModelAndView对象中)填充到request域<br>第十一步：前端控制器向用户响应结果</p><h2 id="spring-与-mybatis整合过程"><a href="#spring-与-mybatis整合过程" class="headerlink" title="spring 与 mybatis整合过程"></a>spring 与 mybatis整合过程</h2><p>第一步：整合dao层<br>    mybatis和spring整合，通过spring管理mapper接口。<br>    使用mapper的扫描器自动扫描mapper接口在spring中进行注册。<br>第二步：整合service层<br>    通过spring管理 service接口。<br>    使用配置方式将service接口配置在spring配置文件中。<br>    实现事务控制。<br>第三步：整合springmvc<br>    由于springmvc是spring的模块，不需要整合。<br>主要配置有：<br>1). mybatis配置文件sqlMapConfig.xml配置别名自动扫描(实体类)<br>2). mapper扫描器(接口，数据库访问接口)<br>3). 数据库连接池配置<br>4). 声明式事务配置<br>5). 启用注解扫描：&lt;context:component-scan base-package=”cn.itcast.ssm.controller”&gt;&lt;/context:component-scan&gt;<br>6). 配置注解映射器和适配器： <a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>&lt;/mvc:annotation-driven&gt;<br>7). 视图解析器：<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"><br>8). 配置控制类： DispatcherServlet前端控制器<br>9). 配置spring配置文件加载类：ClassLoadListener</bean></p><h2 id="静态资源访问不被拦截："><a href="#静态资源访问不被拦截：" class="headerlink" title="静态资源访问不被拦截："></a>静态资源访问不被拦截：</h2><p><resources mapping="/resources/**" location="/resources/"></resources></p><p><resources mapping="/images/**" location="/images/"></resources></p><resources mapping="/js/**" location="/js/"><h2 id="RequestMapping的作用"><a href="#RequestMapping的作用" class="headerlink" title="@RequestMapping的作用"></a>@RequestMapping的作用</h2><p>1). url映射<br>2). 窄化请求映射<br>3). 限制http请求方法</p><h2 id="controller方法的返回值"><a href="#controller方法的返回值" class="headerlink" title="controller方法的返回值"></a>controller方法的返回值</h2><h3 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h3><p>需要方法结束时，定义ModelAndView，将model和view分别进行设置。 </p><h3 id="返回string"><a href="#返回string" class="headerlink" title="返回string"></a>返回string</h3><p>如果controller方法返回string，<br>1). 表示返回逻辑视图名。真正视图(jsp路径)=前缀+逻辑视图名+后缀<br>2). redirect重定向：返回字符串格式为：”redirect:queryItem.action”<br>3). forward页面转发：返回字符串格式为：“forward:queryItem.action”</p><h3 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h3><p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：<br>1). 使用request转向页面，如下：request.getRequestDispatcher(“页面路径”).forward(request, response);<br>2). 也可以通过response页面重定向：response.sendRedirect(“url”)<br>3). 也可以通过response指定响应结果，例如响应json数据如下：<br>    response.setCharacterEncoding(“utf-8”);<br>    response.setContentType(“application/json;charset=utf-8”);<br>    response.getWriter().write(“json串”);</p><h2 id="参数绑定："><a href="#参数绑定：" class="headerlink" title="参数绑定："></a>参数绑定：</h2><h3 id="默认支持的类型"><a href="#默认支持的类型" class="headerlink" title="默认支持的类型"></a>默认支持的类型</h3><p>直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。<br>1). HttpServletRequest：通过request对象获取请求信息<br>2). HttpServletResponse：通过response处理响应信息<br>3). HttpSession：通过session对象得到session中存放的对象<br>4). Model/ModelMap：model是一个接口，modelMap是一个接口实现 。作用：将model数据填充到request域。</p><h3 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h3><p>通过@RequestParam对简单类型的参数进行绑定。<br>如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。<br>如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。<br>通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，会报错。</p><h3 id="pojo绑定"><a href="#pojo绑定" class="headerlink" title="pojo绑定"></a>pojo绑定</h3><p>页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo。(usename,age；不需要user.username,user.age)</p><h3 id="自定义参数绑定实现日期类型绑定"><a href="#自定义参数绑定实现日期类型绑定" class="headerlink" title="自定义参数绑定实现日期类型绑定"></a>自定义参数绑定实现日期类型绑定</h3><p>对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。将请求日期数据串转成 日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。</p><h2 id="Spring-MVC-和-Struts2-对比"><a href="#Spring-MVC-和-Struts2-对比" class="headerlink" title="Spring MVC 和 Struts2 对比"></a>Spring MVC 和 Struts2 对比</h2><ul><li>1). Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上SpringMVC 就容易实现restful url</li><li>2). 由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法<br>  之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。</li><li>3). 由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。</li><li>4). SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己<br>  写代码集成进去，使用起来也相对不方便。</li><li>5). springmvc面向方法开发的（更接近service接口的开发方式），struts2面向类开发。</li><li>6). springmvc可以单例开发，struts2只能是多例开发。</li></ul><h2 id="乱码处理"><a href="#乱码处理" class="headerlink" title="乱码处理"></a>乱码处理</h2><ul><li>1). post乱码<br>在web.xml添加post乱码filter：CharacterEncodingFilter</li><li>2). 对于get请求中文参数出现乱码解决方法有两个：<br>a. 修改tomcat配置文件添加编码与工程编码一致，如下：<br><connector uriencoding="utf-8" connectiontimeout="20000" port="8080" protocol="HTTP/1.1" redirectport="8443"><br>b. 对参数进行重新编码：<br>String userName = new  String(request.getParamter(“userName”).getBytes(“ISO8859-1”),”utf-8”)<br>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</connector></li></ul><h2 id="集合类型绑定"><a href="#集合类型绑定" class="headerlink" title="集合类型绑定"></a>集合类型绑定</h2><ul><li>1). 数组绑定：<br>  controller方法参数使用：(Integer[] itemId)<br>  页面统一使用:itemId 作为name</li><li>2). list绑定：<br>  pojo属性名为：itemsList<br>  页面：itemsList[index].属性名</li><li>3). map 绑定：<br>  pojo属性名为：Map&lt;String, Object&gt; itemInfo = new HashMap&lt;String, Object&gt;();<br>  页面： <td>姓名：&lt;inputtype=”text”name=”itemInfo[‘name’]”/&gt;</td></li></ul><h2 id="spring-校验"><a href="#spring-校验" class="headerlink" title="spring 校验"></a>spring 校验</h2><ul><li>1). 项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。</li><li>2). springmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。<br>  校验思路：页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面。</li></ul><h2 id="数据回显"><a href="#数据回显" class="headerlink" title="数据回显"></a>数据回显</h2><p>1). @ModelAttribute还可以将方法的返回值传到页面：在方法上加注解@ModelAttribute<br>2). 使用最简单方法使用model，可以不用@ModelAttribute：model.addAttribute(“id”, id);<br>3). springmvc默认对pojo数据进行回显。pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写）<br>4). public String testParam(PrintWriter out, @RequestParam(“username”) String username) { //out直接输出</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。<br>系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。</p><h2 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h2><ul><li>1). 在页面form中提交enctype=”multipart/form-data”的数据时，需要springmvc对multipart类型的数据进行解析。</li><li><p>2). 在springmvc.xml中配置multipart类型解析器。</p></li><li><p>3). 方法中使用：MultipartFile attach (单个文件上传) 或者  MultipartFile[] attachs (多个文件上传)</p></li><li><p><img src="https://upload.cc/i1/2019/04/10/zSkeqW.png" alt="pic"></p></li></ul></resources>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在学习Spring家族的时候，不免接触到许多底层概念和原理，于是为加深理解和印象，网上找到了一位大神的总结，特意转载学习~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/doudouxiaoye/p/5693399.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文部分转载至这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么使用Spring&quot;&gt;&lt;a href=&quot;#为什么使用Spring&quot; class=&quot;headerlink&quot; title=&quot;为什么使用Spring ?&quot;&gt;&lt;/a&gt;为什么使用Spring ?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1). 方便解耦，简化开发&lt;br&gt;通过Spring提供的IoC容器，可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。&lt;/li&gt;
&lt;li&gt;2). AOP编程的支持&lt;br&gt;通过Spring提供的AOP功能，方便进行面向切面的编程，如性能监测、事务管理、日志记录等。&lt;/li&gt;
&lt;li&gt;3). 声明式事务的支持&lt;/li&gt;
&lt;li&gt;4). 方便集成各种优秀框架&lt;/li&gt;
&lt;li&gt;5). 降低Java EE API的使用难度&lt;br&gt;如对JDBC，JavaMail，远程调用等提供了简便封装&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是IoC，为什使用IoC&quot;&gt;&lt;a href=&quot;#什么是IoC，为什使用IoC&quot; class=&quot;headerlink&quot; title=&quot;什么是IoC，为什使用IoC ?&quot;&gt;&lt;/a&gt;什么是IoC，为什使用IoC ?&lt;/h2&gt;&lt;p&gt;IoC全称Iversion of Controller，控制反转。&lt;br&gt;这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。&lt;br&gt;它能指导我们如何设计出松耦合、更优良的程序。&lt;br&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://traveler-wm.github.io/tags/Spring/"/>
    
      <category term="Spring MVC" scheme="https://traveler-wm.github.io/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>Materialize框架的一些惊艳效果</title>
    <link href="https://traveler-wm.github.io/2019/04/03/Materialize%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%8A%E8%89%B3%E6%95%88%E6%9E%9C/"/>
    <id>https://traveler-wm.github.io/2019/04/03/Materialize框架的一些惊艳效果/</id>
    <published>2019-04-03T12:50:21.000Z</published>
    <updated>2019-04-03T13:54:54.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="About"><a href="#About" class="headerlink" title="About"></a>About</h1><h2 id="一个基于Material-Design的现代响应式前端框架"><a href="#一个基于Material-Design的现代响应式前端框架" class="headerlink" title="一个基于Material Design的现代响应式前端框架"></a>一个基于Material Design的现代响应式前端框架</h2><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>响应式设计，根据设备大小重新设计自己，适合任何屏幕尺寸</li><li>设计简约，标准CSS，占地面积最小。</li><li>包括新版本的通用用户界面控件，如按钮，复选框和文本字段，这些控件适用于材料设计概念。</li><li>包括增强和专门的功能，如卡，标签，导航栏，toasts等。</li><li>需要jQuery javascript库才能正常工作。</li><li>跨浏览器，并且可以用于创建可重用的Web组件。</li><li>免费使用</li></ul><p><a href="http://www.materializecss.cn/" target="_blank" rel="noopener">中文文档</a></p><p><a href="https://materializecss.com/" target="_blank" rel="noopener">英文文档</a><br><a id="more"></a></p><h2 id="一些惊艳效果"><a href="#一些惊艳效果" class="headerlink" title="一些惊艳效果"></a>一些惊艳效果</h2><h3 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h3><p><img src="https://upload.cc/i1/2019/04/03/GFRKBv.jpg" alt="pic1"></p><p>这个轮播效果类似于幻灯片播放，看起来还是不错的!</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现 :"></a>实现 :</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="carousel"&gt;</span><br><span class="line">    &lt;a class="carousel-item" href="#one!"&gt;&lt;img src="/images/nature/lorempixel1.jpg"&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a class="carousel-item" href="#two!"&gt;&lt;img src="/images/nature/lorempixel2.jpg"&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a class="carousel-item" href="#three!"&gt;&lt;img src="/images/nature/lorempixel3.jpg"&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a class="carousel-item" href="#four!"&gt;&lt;img src="/images/nature/lorempixel4.jpg"&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a class="carousel-item" href="#five!"&gt;&lt;img src="/images/nature/lorempixel5.jpg"&gt;&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="记得JQuery初始化"><a href="#记得JQuery初始化" class="headerlink" title="记得JQuery初始化"></a>记得JQuery初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function()&#123;</span><br><span class="line">      $(&apos;.carousel&apos;).carousel();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="响应式嵌入"><a href="#响应式嵌入" class="headerlink" title="响应式嵌入"></a>响应式嵌入</h2><h3 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h3><p>将类response-img添加到图像标记中可以根据页面宽度调整图像大小，将class =“circle”添加可以使图像显示为圆形。</p><p><img src="https://upload.cc/i1/2019/04/03/KPRigO.jpg" alt="pic2"></p><h3 id="视频嵌入"><a href="#视频嵌入" class="headerlink" title="视频嵌入"></a>视频嵌入</h3><p>为了使你的嵌入响应，只需用包含div的视频容器class =“video-container”包裹它们</p><p><img src="https://upload.cc/i1/2019/04/03/ohPrzx.jpg" alt="pic3"></p><h2 id="丰富的图标"><a href="#丰富的图标" class="headerlink" title="丰富的图标"></a>丰富的图标</h2><p>Material拥有932种图标资源，非常丰富</p><p>使用 ：</p><p><code>head</code>标签引入下列代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;https://fonts.googleapis.com/icon?family=Material+Icons&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>支持<code>tiny</code>、<code>small</code>、<code>medium</code>、<code>large</code>四种尺寸</p><p><img src="https://i.loli.net/2019/04/03/5ca4b87ab399b.jpg" alt="pic4"></p><h2 id="卡片式呈现"><a href="#卡片式呈现" class="headerlink" title="卡片式呈现"></a>卡片式呈现</h2><p>卡片是显示由不同类型的对象组成的内容的便利方式。它们也非常适合呈现类似对象，其大小或支持的操作可能会有很大差异，例如带有可变长度字幕的照片。<br>可以设置卡片小中大三种尺寸</p><p>带有图文及链接的卡片:</p><p><img src="https://i.loli.net/2019/04/03/5ca4b9f624b8f.jpg" alt="pic5"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;About&quot;&gt;&lt;a href=&quot;#About&quot; class=&quot;headerlink&quot; title=&quot;About&quot;&gt;&lt;/a&gt;About&lt;/h1&gt;&lt;h2 id=&quot;一个基于Material-Design的现代响应式前端框架&quot;&gt;&lt;a href=&quot;#一个基于Material-Design的现代响应式前端框架&quot; class=&quot;headerlink&quot; title=&quot;一个基于Material Design的现代响应式前端框架&quot;&gt;&lt;/a&gt;一个基于Material Design的现代响应式前端框架&lt;/h2&gt;&lt;h2 id=&quot;Features&quot;&gt;&lt;a href=&quot;#Features&quot; class=&quot;headerlink&quot; title=&quot;Features&quot;&gt;&lt;/a&gt;Features&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;响应式设计，根据设备大小重新设计自己，适合任何屏幕尺寸&lt;/li&gt;
&lt;li&gt;设计简约，标准CSS，占地面积最小。&lt;/li&gt;
&lt;li&gt;包括新版本的通用用户界面控件，如按钮，复选框和文本字段，这些控件适用于材料设计概念。&lt;/li&gt;
&lt;li&gt;包括增强和专门的功能，如卡，标签，导航栏，toasts等。&lt;/li&gt;
&lt;li&gt;需要jQuery javascript库才能正常工作。&lt;/li&gt;
&lt;li&gt;跨浏览器，并且可以用于创建可重用的Web组件。&lt;/li&gt;
&lt;li&gt;免费使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.materializecss.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://materializecss.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;英文文档&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="materialize" scheme="https://traveler-wm.github.io/tags/materialize/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客图床选择</title>
    <link href="https://traveler-wm.github.io/2019/04/03/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E9%80%89%E6%8B%A9/"/>
    <id>https://traveler-wm.github.io/2019/04/03/博客图床选择/</id>
    <published>2019-04-03T10:29:01.000Z</published>
    <updated>2019-04-03T12:42:17.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>我们在使用博客时候，不免经常要展示一些图文方便说明。很多人把图片寄存于网络，<br>用服务厂商作为图片存储的地方，大家都叫为「图床」，通过上传到云上的图片会获得一个链接，<br>于是在写文章的时候便可以利用markdown语法链接图片资源。</p><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><h2 id="公共图床"><a href="#公共图床" class="headerlink" title="公共图床"></a>公共图床</h2><h3 id="以下的图床支持图片一键式拖拽上传并直接生成链接，无需注册也是个人推荐的方式"><a href="#以下的图床支持图片一键式拖拽上传并直接生成链接，无需注册也是个人推荐的方式" class="headerlink" title="以下的图床支持图片一键式拖拽上传并直接生成链接，无需注册也是个人推荐的方式"></a>以下的图床支持图片一键式拖拽上传并直接生成链接，无需注册也是个人推荐的方式</h3><ul><li><p><a href="https://imgchr.com/" target="_blank" rel="noopener">imgchr</a></p><a id="more"></a><p>  <img src="https://upload.cc/i1/2019/04/03/lQwohO.jpg" alt="imgchr"></p></li><li><p><a href="http://tuchuang.org/" target="_blank" rel="noopener">Qchan</a></p><p>  <img src="https://upload.cc/i1/2019/04/03/1caSn9.jpg" alt="qchan"></p></li><li><p><a href="https://pic.xiaojianjian.net/" target="_blank" rel="noopener">小贱贱图床</a><br>  <img src="https://upload.cc/i1/2019/04/03/bTzkop.jpg" alt="小贱贱"></p></li><li><p><a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a></p><p>  <img src="https://upload.cc/i1/2019/04/03/QHXs9b.jpg" alt="SM.MS"></p></li><li><p><a href="https://upload.cc/" target="_blank" rel="noopener">Upload.cc</a></p><p>  <img src="https://upload.cc/i1/2019/04/03/EBzuXD.jpg" alt="upload.cc"></p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://weibo.com/login.php?url=https%3A%2F%2Fweibo.com%2Fminipublish" target="_blank" rel="noopener">微博图床</a></li></ul><p>特点:</p><p>免费，没有容量限制，全网 CDN 加速，支持 HTTPS,但是上传的图片会被转成 jpg，且图片会被加上水印</p><h2 id="自建图床"><a href="#自建图床" class="headerlink" title="自建图床"></a>自建图床</h2><h2 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h2><ul><li><a href="https://www.qiniu.com/?hmsr=baidu&amp;hmpl=SEM&amp;hmcu=pinzhuan_title&amp;hmkw=&amp;hmci=" target="_blank" rel="noopener">七牛云</a></li><li><a href="https://www.upyun.com/" target="_blank" rel="noopener">又拍云</a></li><li><a href="https://www.aliyun.com/product/oss/" target="_blank" rel="noopener">阿里云oss</a></li></ul><h2 id="开源方案"><a href="#开源方案" class="headerlink" title="开源方案"></a>开源方案</h2><ul><li><a href="https://github.com/electerious/Lychee" target="_blank" rel="noopener">Lychee</a></li><li><a href="https://yun.aoaoao.me/" target="_blank" rel="noopener">树洞外链</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/qq_21956483/article/details/82758543" target="_blank" rel="noopener">https://blog.csdn.net/qq_21956483/article/details/82758543</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;我们在使用博客时候，不免经常要展示一些图文方便说明。很多人把图片寄存于网络，&lt;br&gt;用服务厂商作为图片存储的地方，大家都叫为「图床」，通过上传到云上的图片会获得一个链接，&lt;br&gt;于是在写文章的时候便可以利用markdown语法链接图片资源。&lt;/p&gt;
&lt;h1 id=&quot;选择&quot;&gt;&lt;a href=&quot;#选择&quot; class=&quot;headerlink&quot; title=&quot;选择&quot;&gt;&lt;/a&gt;选择&lt;/h1&gt;&lt;h2 id=&quot;公共图床&quot;&gt;&lt;a href=&quot;#公共图床&quot; class=&quot;headerlink&quot; title=&quot;公共图床&quot;&gt;&lt;/a&gt;公共图床&lt;/h2&gt;&lt;h3 id=&quot;以下的图床支持图片一键式拖拽上传并直接生成链接，无需注册也是个人推荐的方式&quot;&gt;&lt;a href=&quot;#以下的图床支持图片一键式拖拽上传并直接生成链接，无需注册也是个人推荐的方式&quot; class=&quot;headerlink&quot; title=&quot;以下的图床支持图片一键式拖拽上传并直接生成链接，无需注册也是个人推荐的方式&quot;&gt;&lt;/a&gt;以下的图床支持图片一键式拖拽上传并直接生成链接，无需注册也是个人推荐的方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://imgchr.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;imgchr&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Graph bed" scheme="https://traveler-wm.github.io/tags/Graph-bed/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习(四)之springmvc项目部署</title>
    <link href="https://traveler-wm.github.io/2019/03/25/Docker%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E4%B9%8Bspringmvc%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <id>https://traveler-wm.github.io/2019/03/25/Docker学习-四-之springmvc项目部署/</id>
    <published>2019-03-25T12:21:56.000Z</published>
    <updated>2019-04-10T16:07:30.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在学习了之前的docker基础后，这次我们便通过部署一个springmvc应用来练练手。默认你已经购买了一台云服务器<br>或者也可以在虚拟机上进行。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/Traveler-WM/BookMS" target="_blank" rel="noopener">https://github.com/Traveler-WM/BookMS</a></p><h2 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h2><ul><li>一个springmvc应用，可以<code>git clone</code>上面的项目</li><li>在云服务器中安装docker并拉取所需的tomcat和mysql镜像</li></ul><p>作为docker实战，我们第一步便检查docker是否安装并正常运行，docker的安装可以参考我之前的博文<br>这里我用的是CentOS 7的Linux系统<br>拉取最新版的tomcat镜像<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p>拉去好后创建mysql容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br></pre></td></tr></table></figure><p>命令解释:</p><ul><li>run -itd：在docker中运行一个带交互式的且能后台运行的容器。</li><li>–name mysql:给容器命名为mysql，注意name前面有两个小横杠，你也可以自己随意命名。</li><li>-p 3306:3306：这里是指将容器的3306端口映射到主机的3306端口，冒号前面指的是主机，后面指的是容器。</li><li>-e MY_ROOT_PASSWORD=123456:这行命令的意思是在创建mysql容器的时候在容器中创建一个root用户，密码为<br>123456，也可以自行设置。</li></ul><p>接下来我们尝试用数据库连接工具navicat连接远程数据库mysql</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1.设置权限（为root分配权限，以便可以远程连接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all PRIVILEGES on *.* to root@&apos;%&apos; WITH GRANT OPTION</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>2.由于Mysql5.6以上的版本修改了Password算法，这里需要更新密码算法</p><p>当我们尝试连接时，可能会出现数据库连接错误，显示密码乱码的问题</p><p>解决途径:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER user &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE NEVER;</span><br><span class="line">Query OK, 0 rows affected (0.11 sec) </span><br><span class="line">mysql&gt; ALTER user &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;;</span><br><span class="line">Query OK, 0 rows affected (0.11 sec) </span><br><span class="line">mysql&gt;  FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>数据库连接成功后，我们通过命令拉去tomcat镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure><p>接下来部署提供web服务的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 80:8080 --name myweb tomcat</span><br></pre></td></tr></table></figure><p>创建好了tomcat容器后，我们可以在浏览器输入<strong>&lt;你的ip&gt;</strong>检查一下tomcat是否部署成功。</p><p>接下来我们通过命令<code>docker exec -it myweb bash</code>进入myweb容器</p><p>之后看到有一个tomcat目录下有一个webapps的目录，我们需要把之前准备的springmvc应用的工程文件导出为war包，<br>在导入war包之前，我们要查看一下mysql容器的ip，可以通过命令<code>cat /etc/hosts</code>,然后在springmvc工程文件中访问数据库的xml配置文件里修改访问的数据库。</p><p>最后可以通过命令拷贝放到这里的webapps目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /mnt/MPS_system.war fa0be9ddda5c1d667be886ad28e9895e37d17b839677e215a0dfb7e961b6c974:/usr/local/tomcat/webapps</span><br></pre></td></tr></table></figure><p>这个命令是把在/mnt下的MPS_system.war文件拷贝到myweb容器下的webapps目录下。里面很长的那个字符串是容器的id，这里用myweb应该也可以（myweb是我tomcat容器的容器名字），后面是webapps在容器中的路径，是固定的，直接复制即可。 </p><p>这样tomcat会帮我们解压部署，部署完成之后我们在浏览器中输入服务器ip+war包文件名便可以看到项目成功地运行了起来！！（我们也可以把解压好的目录下的所有文件放到ROOT目录下，该目录是tomcat的默认运行目录，这样我们可以直接通过地址栏中输入ip运行项目）</p><p>ps:可以用通过目录挂载的方式保存项目数据。</p><p>原因:<br>只要是容器内的数据，当容器删除或者重启时，以前的数据就会消失，于是搜索问题发现的解决的方法是Docker目录挂载从镜像启动容器的时候，用-v的命令，将容器里的目录和宿主机的一个目录关联起来，容器里面目录里面的内容如果修改了，宿主机挂载的目录里面的内容也会跟着修改，而且当容器被删除时，宿主机里面的数据不会消失。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/bad_yu/article/details/81098032" target="_blank" rel="noopener">https://blog.csdn.net/bad_yu/article/details/81098032</a></li><li><a href="https://blog.csdn.net/xsj34567/article/details/80940238" target="_blank" rel="noopener">https://blog.csdn.net/xsj34567/article/details/80940238</a></li><li><a href="https://blog.csdn.net/wchenjt/article/details/79118798" target="_blank" rel="noopener">https://blog.csdn.net/wchenjt/article/details/79118798</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;在学习了之前的docker基础后，这次我们便通过部署一个springmvc应用来练练手。默认你已经购买了一台云服务器&lt;br&gt;或者也可以在虚拟机上进行。&lt;/p&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;#项目地址&quot; class=&quot;headerlink&quot; title=&quot;项目地址&quot;&gt;&lt;/a&gt;项目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Traveler-WM/BookMS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Traveler-WM/BookMS&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;部署准备&quot;&gt;&lt;a href=&quot;#部署准备&quot; class=&quot;headerlink&quot; title=&quot;部署准备&quot;&gt;&lt;/a&gt;部署准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个springmvc应用，可以&lt;code&gt;git clone&lt;/code&gt;上面的项目&lt;/li&gt;
&lt;li&gt;在云服务器中安装docker并拉取所需的tomcat和mysql镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为docker实战，我们第一步便检查docker是否安装并正常运行，docker的安装可以参考我之前的博文&lt;br&gt;这里我用的是CentOS 7的Linux系统&lt;br&gt;拉取最新版的tomcat镜像&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://traveler-wm.github.io/tags/docker/"/>
    
      <category term="Spring MVC" scheme="https://traveler-wm.github.io/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习(三)之Dockerfile笔记</title>
    <link href="https://traveler-wm.github.io/2019/03/15/Docker%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E4%B9%8BDockerfile%E4%BB%8B%E7%BB%8D/"/>
    <id>https://traveler-wm.github.io/2019/03/15/Docker学习-三-之Dockerfile介绍/</id>
    <published>2019-03-15T02:25:44.000Z</published>
    <updated>2019-03-15T05:16:18.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile构建镜像"><a href="#Dockerfile构建镜像" class="headerlink" title="Dockerfile构建镜像"></a>Dockerfile构建镜像</h1><p>镜像作为Docker的一个重要概念，其实际上就是定制每一层所添加的配置、文件。而Dockerfile就是一个脚本文件，用于把该每一层修改、安装、构建、操作的命令写入其中来构建、定制镜像。</p><p>Dockerfile是一个文本文档，其中包含用户可以在命令行上调用来构建镜像的所有命令。 使用Dockerfile用户可以创建一个连续执行多个命令行指令的镜像。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h2><p>以构建nginx镜像为例，在一个空白目录，建立一个文本文件，并命名为 dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mynginx</span><br><span class="line">$ cd mynginx</span><br><span class="line">$ touch dockerfile</span><br></pre></td></tr></table></figure><p>在该dockerfile中写入内容:<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p><p>这个dockerile比较简单，用到了<code>FROM</code>和<code>RUN</code>两条命令，意思是基于nginx镜像,运行echo命令重定向输出<code>&lt;h1&gt;</code>标签内容到index.html文件中</p><h1 id="Dockerfile常用命令"><a href="#Dockerfile常用命令" class="headerlink" title="Dockerfile常用命令"></a>Dockerfile常用命令</h1><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p>格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br><span class="line">或</span><br><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>FROM在Dockerfile中是必须的指令，而且必须是第一条指令。它以一个镜像为基础，在其上进行定制，该基础镜像首选本地是否存在，如果不存在则会从公共仓库下载（当然也可以使用私有仓库的格式）</p><ul><li>通过Docker Hub官方镜像仓库的镜像，比如服务类(nginx/redis)、语言类(node/openjdk/python)、操作系统类(ubuntu/debian/centos)等，我们可以直接pull下来进行基础构建。</li><li>除了选择现有的镜像作为基础镜像外，Docker还存在一个特殊的镜像，名为scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像 </li></ul><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>run指令是用来执行命令行命令的，定制镜像时是最常用的指令之一。其格式有两种:</p><ul><li>shell格式： RUN 命令，就像直接在命令行中输入的命令一样，如RUN echo ‘hello, world!’ &gt; hello.txt</li><li>exec格式：RUN [‘可执行文件’, ‘参数1’, ‘参数2’]，这更像是函数调用中的格式。如RUN /bin/bash -c ‘source $HOME/.bashrc; echo $HOME’</li></ul><p>Dockerfile中每一个指令都会建立一层，RUN也不例外。每一个RUN的行为，就和刚才我们手工建立镜像的过程一样:新建立一层，在其上执行这些命令，执行结束后，commit这一层的修改，构成新的镜像。所以在使用RUN命令时应当尽可能地减少层数，避免构建了多层、臃肿的镜像，既增加了构建部署的时间，也很容易出错（可以使用&amp;&amp;将各个所需命令串联起来）</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD指令的主要功能是在build完成后，为了给docker run启动到容器时提供默认命令或参数，这些默认值可以包含可执行的命令，也可以只是参数（此时可执行命令就必须提前在ENTRYPOINT中指定)。Dockerfile中只能有一条CMD指令。如果列出多个CMD，则只有最后一个CMD才会生效</p><p>CMD命令包含三种结构:</p><ul><li>CMD [“executable”,”param1”,”param2”] (exec格式首选)</li><li>CMD [“param1”,”param2”] (作为ENTRYPOINT的默认变量)</li><li>CMD command param1 param2 (shell格式)</li></ul><p>CMD与RUN的区别在于，RUN是在build成镜像时就运行的，先于CMD和ENTRYPOINT的，CMD会在每次启动容器的时候运行，而RUN只在创建镜像时执行一次，固化在image中。</p><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br></pre></td></tr></table></figure><p>将文件<code>&lt;src&gt;</code>拷贝到container的文件系统对应的路径<code>&lt;dest&gt;</code>下。<code>&lt;src&gt;</code>可以是文件、文件夹、URL，对于文件和文件夹<src>必须是在Dockerfile的相对路径下（build context path），即只能是相对路径且不能包含../path/。</src></p><p><code>&lt;dest&gt;</code>只能是容器中的绝对路径。如果路径不存在则会自动级联创建，根据你的需要是<code>&lt;dest&gt;</code>里是否需要反斜杠/，习惯使用/结尾从而避免被当成文件</p><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p>COPY 指令将从构建上下文目录中&lt;源路径&gt;的文件复制到新的一层的镜像内的&lt;目标路径&gt;位置。</p><p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用：</p><p>COPY &lt;源路径&gt;… &lt;目标路径&gt;<br>COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</p><p>COPY的语法与功能与ADD相同，只是不支持上面讲到的<src>是远程URL、自动解压这两个特性。推荐使用COPY，虽然COPY只支持本地文件拷贝到container，但它的处理比ADD更加透明，建议只在复制tar文件时使用ADD，如ADD trusty-core-amd64.tar.gz /。</src></p><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>用于设置环境变量<br>格式有两种：</p><ul><li>ENV <code>&lt;key&gt;</code> <code>&lt;value&gt;</code></li><li>ENV <code>&lt;key1&gt;</code>=<code>&lt;value1&gt;</code> <code>&lt;key2&gt;</code>=<code>&lt;value2&gt;</code>…</li></ul><p>设置了后，后续的RUN命令都可以使用，当运行生成的镜像时这些环境变量依然有效，如果需要在运行时更改这些环境变量可以在运行docker run时添加-env <code>&lt;key&gt;</code>=<code>&lt;value&gt;</code>参数来修改。</p><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>EXPOSE指令告诉容器在运行时要监听的端口，但是这个端口是用于多个容器之间通信用的（links），外面的host是访问不到的。要把端口暴露给外面的主机，在启动容器时使用-p选项。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># expose memcached(s) port</span><br><span class="line">EXPOSE 11211 11212</span><br></pre></td></tr></table></figure><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>WORKDIR指令用于设置Dockerfile中的RUN、CMD和ENTRYPOINT指令执行命令的工作目录(默认为/目录)，该指令在Dockerfile文件中可以出现多次，如果使用相对路径则为相对于WORKDIR上一次的值，例如WORKDIR /a，WORKDIR b，RUN pwd最终输出的当前目录是/a/b。（RUN cd /a/b，RUN pwd是得不到/a/b的）</p><h1 id="Dockerfile示例"><a href="#Dockerfile示例" class="headerlink" title="Dockerfile示例"></a>Dockerfile示例</h1><p>下面的Dockerfile是MySQL官方镜像的构建过程。从ubuntu基础镜像开始构建，安装mysql-server、配置权限、映射目录和端口，CMD在从这个镜像运行到容器时启动mysql。其中VOLUME定义的两个可挂载点，用于在host中挂载，因为数据库保存在主机上而非容器中才是比较安全的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># MySQL Dockerfile</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># https://github.com/dockerfile/mysql</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pull base image.</span></span><br><span class="line">FROM dockerfile/ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install MySQL.</span></span><br><span class="line">RUN \</span><br><span class="line">  apt-get update &amp;&amp; \</span><br><span class="line">  DEBIAN_FRONTEND=noninteractive apt-get install -y mysql-server &amp;&amp; \</span><br><span class="line">  rm -rf /var/lib/apt/lists/* &amp;&amp; \</span><br><span class="line">  sed -i <span class="string">'s/^\(bind-address\s.*\)/# \1/'</span> /etc/mysql/my.cnf &amp;&amp; \</span><br><span class="line">  sed -i <span class="string">'s/^\(log_error\s.*\)/# \1/'</span> /etc/mysql/my.cnf &amp;&amp; \</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"mysqld_safe &amp;"</span> &gt; /tmp/config &amp;&amp; \</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"mysqladmin --silent --wait=30 ping || exit 1"</span> &gt;&gt; /tmp/config &amp;&amp; \</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"mysql -e 'GRANT ALL PRIVILEGES ON *.* TO \"root\"@\"%\" WITH GRANT OPTION;'"</span> &gt;&gt; /tmp/config &amp;&amp; \</span><br><span class="line">  bash /tmp/config &amp;&amp; \</span><br><span class="line">  rm -f /tmp/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define mountable directories.</span></span><br><span class="line">VOLUME [<span class="string">"/etc/mysql"</span>, <span class="string">"/var/lib/mysql"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define working directory.</span></span><br><span class="line">WORKDIR /data</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define default command.</span></span><br><span class="line">CMD [<span class="string">"mysqld_safe"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expose ports.</span></span><br><span class="line">EXPOSE 3306</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t=<span class="string">"dockerfile/mysql"</span> github.com/dockerfile/mysql</span><br><span class="line"></span><br><span class="line">或下载Dockerfile内容再当前目录：</span><br><span class="line">$ docker build -t=<span class="string">"dockerfile/mysql"</span> .</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name mysql -p 3306:3306 dockerfile/mysql</span><br><span class="line">或</span><br><span class="line">$ docker run -it --rm --link mysql:mysql dockerfile/mysql bash -c <span class="string">'mysql -h $MYSQL_PORT_3306_TCP_ADDR'</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a></li><li><a href="http://seanlook.com/2014/11/17/dockerfile-introduction/" target="_blank" rel="noopener">Dockerfile指令详解</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/image/build.html" target="_blank" rel="noopener">Docker——从入门到实践</a></li><li><a href="https://blog.devzeng.com/blog/build-docker-image-with-dockerfile.html" target="_blank" rel="noopener">使用Dockerfile构建Docker镜像</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Dockerfile构建镜像&quot;&gt;&lt;a href=&quot;#Dockerfile构建镜像&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile构建镜像&quot;&gt;&lt;/a&gt;Dockerfile构建镜像&lt;/h1&gt;&lt;p&gt;镜像作为Docker的一个重要概念，其实际上就是定制每一层所添加的配置、文件。而Dockerfile就是一个脚本文件，用于把该每一层修改、安装、构建、操作的命令写入其中来构建、定制镜像。&lt;/p&gt;
&lt;p&gt;Dockerfile是一个文本文档，其中包含用户可以在命令行上调用来构建镜像的所有命令。 使用Dockerfile用户可以创建一个连续执行多个命令行指令的镜像。&lt;/p&gt;
&lt;h2 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例:&quot;&gt;&lt;/a&gt;实例:&lt;/h2&gt;&lt;p&gt;以构建nginx镜像为例，在一个空白目录，建立一个文本文件，并命名为 dockerfile:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir mynginx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd mynginx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ touch dockerfile&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在该dockerfile中写入内容:&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://traveler-wm.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习(二)之Docker常用命令</title>
    <link href="https://traveler-wm.github.io/2019/03/10/Docker%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%E4%B9%8BDocker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://traveler-wm.github.io/2019/03/10/Docker学习(二)之Docker常用命令/</id>
    <published>2019-03-10T02:08:34.000Z</published>
    <updated>2019-03-10T05:41:12.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看Docker信息"><a href="#查看Docker信息" class="headerlink" title="查看Docker信息"></a>查看Docker信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#显示Docker版本信息</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"># 显示Docker系统信息</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h1 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h1><h2 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 从Docker Hub查找镜像</span><br><span class="line">docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><a id="more"></a><p>OPTIONS说明</p><ul><li>automated :只列出 automated build类型的镜像</li><li>–no-trunc :显示完整的镜像描述</li><li>-s :列出收藏数不小于指定值的镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查找收藏数大于30的java镜像</span><br><span class="line">docker search -s 30 java</span><br></pre></td></tr></table></figure><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Docker Hub中拉取镜像</span><br><span class="line">docker pull [OPTIONS] NAME[:Tag|DIGEST]</span><br><span class="line"></span><br><span class="line"># 下载java最新版镜像</span><br><span class="line">docker pull java</span><br><span class="line"></span><br><span class="line"># 下载所有名为java的镜像</span><br><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure><h2 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将本地镜像上传到镜像仓库，先登陆镜像仓库</span><br><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br><span class="line"></span><br><span class="line"># 上传本地镜像mynginx:v1到镜像仓库中</span><br><span class="line">docker push mynginx:v1</span><br></pre></td></tr></table></figure><h2 id="Docker-login-logout"><a href="#Docker-login-logout" class="headerlink" title="Docker login/logout"></a>Docker login/logout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 登录到Docker Hub</span><br><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line"></span><br><span class="line"># 登出Docker Hub</span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure><h1 id="本地镜像仓库"><a href="#本地镜像仓库" class="headerlink" title="本地镜像仓库"></a>本地镜像仓库</h1><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地镜像列表</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"># 列出名为java的镜像列表</span><br><span class="line">docker images java</span><br></pre></td></tr></table></figure><h2 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除本地一个或多个镜像</span><br><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]  </span><br><span class="line"></span><br><span class="line"># 强制删除本地镜像my/nginx:v1</span><br><span class="line">docker rmi -f my/nginx:v1</span><br></pre></td></tr></table></figure><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用Dockerfile创建镜像</span><br><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>OPTIONS说明</p><ul><li>-t 指定镜像的名字 </li><li>-f 指定要使用的Dockerfile路径(Dockerfile 可不在当前路径下）</li></ul><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 最后的.代表使用当前目录的Dockerfile创建镜像</span><br><span class="line">docker build -t my/nginx:v1 .</span><br><span class="line"></span><br><span class="line"># 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span><br><span class="line">docker build github.com/creack/docker-firefox</span><br></pre></td></tr></table></figure><h1 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h1><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个新的容器并运行一个命令</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明</p><ul><li>-d: 后台运行容器，并返回容器ID</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用</li><li>–name: 为容器指定一个名称</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致</li><li>-m :设置容器使用内存最大值</li><li>-p: 映射宿主端口到内部容器开放的网络端口，可以多次使用-p来绑定多个端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</span><br><span class="line">docker run --name mynginx -d nginx:latest</span><br><span class="line"></span><br><span class="line"># 使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data。</span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line"></span><br><span class="line"># 使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令</span><br><span class="line">docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure><h2 id="docker-start-stop-restart"><a href="#docker-start-stop-restart" class="headerlink" title="docker start/stop/restart"></a>docker start/stop/restart</h2><ul><li>docker start :启动一个或多少已经被停止的容器</li><li>docker stop :停止一个运行中的容器</li><li>docker restart :重启容器</li></ul><h2 id="docker-kill"><a href="#docker-kill" class="headerlink" title="docker kill"></a>docker kill</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 杀掉运行中的容器mynginx</span><br><span class="line">docker kill mynginx</span><br></pre></td></tr></table></figure><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除一个或多个容器</span><br><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明</p><ul><li>-f :通过SIGKILL信号强制删除一个运行中的容器</li><li>-l :移除容器间的网络连接，而非容器本身</li><li>-v :删除与容器关联的卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 强制删除容器db01、db02</span><br><span class="line">docker rm -f db01、db02</span><br><span class="line"></span><br><span class="line"># 移除容器nginx01对容器db01的连接，连接名db</span><br><span class="line">docker rm -l db </span><br><span class="line"></span><br><span class="line"># 删除容器nginx01,并删除容器挂载的数据卷</span><br><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure><h2 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在运行的容器中执行命令</span><br><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明</p><ul><li>-d :分离模式: 在后台运行</li><li>-i :即使没有附加也保持STDIN 打开</li><li>-t :分配一个伪终端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在容器mynginx中开启一个交互模式的终端</span><br><span class="line">docker exec -it  mynginx /bin/bash</span><br><span class="line"></span><br><span class="line"># 在容器mynginx中以交互模式执行容器内/root/youj.sh脚本</span><br><span class="line">docker exec -it mynginx /bin/sh /root/youj.sh</span><br></pre></td></tr></table></figure><h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有在运行的容器信息</span><br><span class="line">   docker ps</span><br><span class="line"></span><br><span class="line"># 列出最近创建的5个容器信息</span><br><span class="line">   docker ps -n 5</span><br><span class="line"></span><br><span class="line"># 列出所有创建的容器ID</span><br><span class="line">   docker ps -a -q</span><br></pre></td></tr></table></figure><h2 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看容器mymysql的进程信息</span><br><span class="line">docker top mymysql</span><br></pre></td></tr></table></figure><h2 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 跟踪查看容器mynginx的日志输出</span><br><span class="line">docker logs -f mynginx</span><br><span class="line"></span><br><span class="line"># 查看容器mynginx从2019年3月1日后的最新10条日志     </span><br><span class="line">docker logs --since=&quot;2019-03-01&quot; --tail=10 mynginx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查看Docker信息&quot;&gt;&lt;a href=&quot;#查看Docker信息&quot; class=&quot;headerlink&quot; title=&quot;查看Docker信息&quot;&gt;&lt;/a&gt;查看Docker信息&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#显示Docker版本信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示Docker系统信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker info&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;镜像仓库&quot;&gt;&lt;a href=&quot;#镜像仓库&quot; class=&quot;headerlink&quot; title=&quot;镜像仓库&quot;&gt;&lt;/a&gt;镜像仓库&lt;/h1&gt;&lt;h2 id=&quot;docker-search&quot;&gt;&lt;a href=&quot;#docker-search&quot; class=&quot;headerlink&quot; title=&quot;docker search&quot;&gt;&lt;/a&gt;docker search&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 从Docker Hub查找镜像&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker search [OPTIONS] TERM&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://traveler-wm.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习(一)之Docker简介和安装</title>
    <link href="https://traveler-wm.github.io/2019/03/08/docker%E5%AD%A6%E4%B9%A0(%E4%B8%80)%E4%B9%8BDocker%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/"/>
    <id>https://traveler-wm.github.io/2019/03/08/docker学习(一)之Docker简介和安装/</id>
    <published>2019-03-08T11:01:45.000Z</published>
    <updated>2019-03-10T04:48:37.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>Docker是开发人员和系统管理员使用容器开发，部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。</code></pre><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>Docker 启动快速属于秒级别。</li><li>Docker 需要的资源更少。Docker 在操作系统级别进行虚拟化，Docker 容器和内核交互，几乎没有性能损耗。</li><li>Docker 更轻量。Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。</li><li>高可用和可恢复性。Docker 对业务的高可用支持是通过快速重新部署实现的。</li><li>虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制。<a id="more"></a></li><li>快速创建、删除。虚拟化创建是分钟级别的，Docker 容器创建是秒级别的，Docker 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间</li></ul><h2 id="容器和镜像"><a href="#容器和镜像" class="headerlink" title="容器和镜像"></a>容器和镜像</h2><pre><code>一个容器通过镜像启动。镜像是一个可执行包，包含运行应用程序所需的所有内容——代码、运行时、库、环境变量和配置文件。容器是镜像运行时的实例  </code></pre><h2 id="容器和虚拟机"><a href="#容器和虚拟机" class="headerlink" title="容器和虚拟机"></a>容器和虚拟机</h2><pre><code>容器在Linux上本机运行，并与其他容器共享主机的内核。它运行一个独立的进程，不占用任何其他可执行文件的内存，使其轻量级。相比之下，虚拟机（VM）运行一个完整的“客户”操作系统，通过虚拟机管理程序对主机资源进行虚拟访问。通常，VM提供的环境比大多数应用程序需要的资源更多。    </code></pre><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><p><strong>卸载掉旧版本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></p><p> <strong>安装依赖包</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">      device-mapper-persistent-data \</span><br><span class="line">      lvm2</span><br></pre></td></tr></table></figure></p><p> <strong>设置稳定版仓库</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></p><p><strong>安装最新版Docker CE</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></p><p><strong>启动Docker</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></p><p><strong>运行hellow-word镜像</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure></p><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p><strong>卸载可能存在的旧版本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure></p><p><strong>更新apt索引包</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p><p><strong>安装包通过https使用repository</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></p><p><strong>添加Docker的官方GPG密钥</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></p><p><strong>更新apt包索引</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></p><p><strong>安装最新版Docker CE</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></p><p><strong>PS:安装特定版本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure><p><strong>运行hello-word镜像</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://dockone.io/article/8350" target="_blank" rel="noopener">http://dockone.io/article/8350</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker简介&quot;&gt;&lt;a href=&quot;#Docker简介&quot; class=&quot;headerlink&quot; title=&quot;Docker简介&quot;&gt;&lt;/a&gt;Docker简介&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Docker是开发人员和系统管理员使用容器开发，部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Docker 启动快速属于秒级别。&lt;/li&gt;
&lt;li&gt;Docker 需要的资源更少。Docker 在操作系统级别进行虚拟化，Docker 容器和内核交互，几乎没有性能损耗。&lt;/li&gt;
&lt;li&gt;Docker 更轻量。Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。&lt;/li&gt;
&lt;li&gt;高可用和可恢复性。Docker 对业务的高可用支持是通过快速重新部署实现的。&lt;/li&gt;
&lt;li&gt;虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制。
    
    </summary>
    
    
      <category term="docker" scheme="https://traveler-wm.github.io/tags/docker/"/>
    
  </entry>
  
</feed>
